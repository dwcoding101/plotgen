"type"¦"qualified name"¦"description"
"procedure"¦"apoc.coll.zipToRows"¦"apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair"
"procedure"¦"apoc.coll.partition"¦"apoc.coll.partition(list,batchSize)"
"procedure"¦"apoc.coll.split"¦"apoc.coll.split(list,value) | splits collection on given values rows of lists, value itself will not be part of resulting lists"
"function"¦"apoc.coll.zip"¦"apoc.coll.zip([list1],[list2])"
"function"¦"apoc.coll.pairs"¦"apoc.coll.pairs([1,2,3]) returns [1,2],[2,3],[3,null] "
"function"¦"apoc.coll.pairsMin"¦"apoc.coll.pairsMin([1,2,3]) returns [1,2],[2,3]"
"function"¦"apoc.coll.sum"¦"apoc.coll.sum([0.5,1,2.3])"
"function"¦"apoc.coll.avg"¦"apoc.coll.avg([0.5,1,2.3])"
"function"¦"apoc.coll.min"¦"apoc.coll.min([0.5,1,2.3])"
"function"¦"apoc.coll.max"¦"apoc.coll.max([0.5,1,2.3])"
"function"¦"apoc.coll.contains"¦"apoc.coll.contains(coll, value) optimized contains operation (using a HashSet) (returns single row or not)"
"function"¦"apoc.coll.indexOf"¦"apoc.coll.indexOf(coll, value) | position of value in the list"
"function"¦"apoc.coll.containsAll"¦"apoc.coll.containsAll(coll, values) optimized contains-all operation (using a HashSet) (returns single row or not)"
"function"¦"apoc.coll.containsSorted"¦"apoc.coll.containsSorted(coll, value) optimized contains on a sorted list operation (Collections.binarySearch) (returns single row or not)"
"function"¦"apoc.coll.containsAllSorted"¦"apoc.coll.containsAllSorted(coll, value) optimized contains-all on a sorted list operation (Collections.binarySearch) (returns single row or not)"
"function"¦"apoc.coll.toSet"¦"apoc.coll.toSet([list]) returns a unique list backed by a set"
"function"¦"apoc.coll.sumLongs"¦"apoc.coll.sumLongs([1,3,3])"
"function"¦"apoc.coll.sort"¦"apoc.coll.sort(coll) sort on Collections"
"function"¦"apoc.coll.sortNodes"¦"apoc.coll.sortNodes([nodes], 'name') sort nodes by property"
"function"¦"apoc.coll.sortMaps"¦"apoc.coll.sortMaps([maps], 'name') - sort maps by property"
"function"¦"apoc.coll.union"¦"apoc.coll.union(first, second) - creates the distinct union of the 2 lists"
"function"¦"apoc.coll.subtract"¦"apoc.coll.subtract(first, second) - returns unique set of first list with all elements of second list removed"
"function"¦"apoc.coll.removeAll"¦"apoc.coll.removeAll(first, second) - returns first list with all elements of second list removed"
"function"¦"apoc.coll.intersection"¦"apoc.coll.intersection(first, second) - returns the unique intersection of the two lists"
"function"¦"apoc.coll.disjunction"¦"apoc.coll.disjunction(first, second) - returns the disjunct set of the two lists"
"function"¦"apoc.coll.unionAll"¦"apoc.coll.unionAll(first, second) - creates the full union with duplicates of the two lists"
"function"¦"apoc.coll.shuffle"¦"apoc.coll.shuffle(coll) - returns the shuffled list"
"function"¦"apoc.coll.randomItem"¦"apoc.coll.randomItem(coll)- returns a random item from the list, or null on an empty or null list"
"function"¦"apoc.coll.randomItems"¦"apoc.coll.randomItems(coll, itemCount, allowRepick: false) - returns a list of itemCount random items from the original list, optionally allowing picked elements to be picked again"
"function"¦"apoc.coll.containsDuplicates"¦"apoc.coll.containsDuplicates(coll) - returns true if a collection contains duplicate elements"
"function"¦"apoc.coll.duplicates"¦"apoc.coll.duplicates(coll) - returns a list of duplicate items in the collection"
"function"¦"apoc.coll.duplicatesWithCount"¦"apoc.coll.duplicatesWithCount(coll) - returns a list of duplicate items in the collection and their count, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}]`)"
"function"¦"apoc.coll.occurrences"¦"apoc.coll.occurrences(coll, item) - returns the count of the given item in the collection"
"function"¦"apoc.coll.reverse"¦"apoc.coll.reverse(coll) - returns reversed list"
