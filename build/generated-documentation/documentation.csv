"type"¦"qualified name"¦"description"
"procedure"¦"apoc.algo.betweenness"¦"CALL apoc.algo.betweenness(['TYPE',...],nodes,BOTH) YIELD node, score - calculate betweenness centrality for given nodes"
"procedure"¦"apoc.algo.betweennessCypher"¦"CALL apoc.algo.betweennessCypher(node_cypher,rel_cypher,write) - calculates betweeness  centrality based on cypher input"
"procedure"¦"apoc.algo.closeness"¦"CALL apoc.algo.closeness(['TYPE',...],nodes, INCOMING) YIELD node, score - calculate closeness centrality for given nodes"
"procedure"¦"apoc.algo.cliques"¦"apoc.algo.cliques(minSize) YIELD cliques - search the graph and return all maximal cliques at least at large as the minimum size argument."
"procedure"¦"apoc.algo.cliquesWithNode"¦"apoc.algo.cliquesWithNode(startNode, minSize) YIELD cliques - search the graph and return all maximal cliques that are at least as large than the minimum size argument and contain this node "
"procedure"¦"apoc.algo.cover"¦"apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes"
"procedure"¦"apoc.algo.community"¦"CALL apoc.algo.community(times,labels,partitionKey,type,direction,weightKey,batchSize) - simple label propagation kernel"
"procedure"¦"apoc.algo.pageRank"¦"CALL apoc.algo.pageRank(nodes) YIELD node, score - calculates page rank for given nodes"
"procedure"¦"apoc.algo.pageRankWithConfig"¦"CALL apoc.algo.pageRankWithConfig(nodes,{iterations:_,types:_}) YIELD node, score, info - calculates page rank for given nodes"
"procedure"¦"apoc.algo.pageRankStats"¦"CALL apoc.algo.pageRankStats({iterations:_,types:_,write:true,...}) YIELD nodeCount - calculates page rank on graph  for given nodes and potentially writes back"
"procedure"¦"apoc.algo.pageRankWithCypher"¦"CALL apoc.algo.pageRankWithCypher({iterations,node_cypher,rel_cypher,write,property,numCpu}) - calculates page rank based on cypher input"
"procedure"¦"apoc.algo.aStar"¦"apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance','lat','lon') YIELD path, weight - run A* with relationship property name as cost function"
"procedure"¦"apoc.algo.aStarConfig"¦"apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', {weight:'dist',default:10,x:'lon',y:'lat'}) YIELD path, weight - run A* with relationship property name as cost function"
"procedure"¦"apoc.algo.dijkstra"¦"apoc.algo.dijkstra(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance') YIELD path, weight - run dijkstra with relationship property name as cost function"
"procedure"¦"apoc.algo.allSimplePaths"¦"apoc.algo.allSimplePaths(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes"
"procedure"¦"apoc.algo.dijkstraWithDefaultWeight"¦"apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist"
"procedure"¦"apoc.algo.wcc"¦"CALL apoc.algo.wcc() YIELD number of weakly connected components"
"procedure"¦"apoc.static.get"¦"apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage"
"procedure"¦"apoc.static.getAll"¦"apoc.static.getAll(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage"
"procedure"¦"apoc.static.list"¦"apoc.static.list(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage"
"procedure"¦"apoc.static.set"¦"apoc.static.set(name, value) - stores value under key for server livetime storage, returns previously stored or configured value"
"procedure"¦"apoc.cluster.graph"¦""
"procedure"¦"apoc.coll.zipToRows"¦"apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair"
"procedure"¦"apoc.coll.partition"¦"apoc.coll.partition(list,batchSize)"
"procedure"¦"apoc.coll.split"¦"apoc.coll.split(list,value) | splits collection on given values rows of lists, value itself will not be part of resulting lists"
"procedure"¦"apoc.config.list"¦""
"procedure"¦"apoc.config.map"¦""
"procedure"¦"apoc.convert.setJsonProperty"¦"apoc.convert.setJsonProperty(node,key,complexValue) - sets value serialized to JSON as property with the given name on the node"
"procedure"¦"apoc.convert.toTree"¦"apoc.convert.toTree([paths]) creates a stream of nested documents representing the at least one root of these paths"
"procedure"¦"apoc.couchbase.get"¦"apoc.couchbase.get(nodes, bucket, documentId) yield id, expiry, cas, mutationToken, content - retrieves a couchbase json document by its unique ID."
"procedure"¦"apoc.couchbase.exists"¦"apoc.couchbase.exists(nodes, bucket, documentId) yield value - check whether a couchbase json document with the given ID does exist."
"procedure"¦"apoc.couchbase.insert"¦"apoc.couchbase.insert(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert a couchbase json document with its unique ID."
"procedure"¦"apoc.couchbase.upsert"¦"apoc.couchbase.upsert(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert or overwrite a couchbase json document with its unique ID."
"procedure"¦"apoc.couchbase.append"¦"apoc.couchbase.append(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - append a couchbase json document to an existing one."
"procedure"¦"apoc.couchbase.prepend"¦"apoc.couchbase.prepend(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - prepend a couchbase json document to an existing one."
"procedure"¦"apoc.couchbase.remove"¦"apoc.couchbase.remove(nodes, bucket, documentId) yield id, expiry, cas, mutationToken, content - remove the couchbase json document identified by its unique ID."
"procedure"¦"apoc.couchbase.replace"¦"apoc.couchbase.replace(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - replace the content of the couchbase json document identified by its unique ID."
"procedure"¦"apoc.couchbase.query"¦"apoc.couchbase.query(nodes, bucket, statement) yield queryResult - executes a plain un-parameterized N1QL statement."
"procedure"¦"apoc.couchbase.posParamsQuery"¦"apoc.couchbase.posParamsQuery(nodes, bucket, statement, params) yield queryResult - executes a N1QL statement with positional parameters."
"procedure"¦"apoc.couchbase.namedParamsQuery"¦"apoc.couchbase.namedParamsQuery(nodes, bucket, statement, paramNames, paramValues) yield queryResult - executes a N1QL statement with named parameters."
"procedure"¦"apoc.create.node"¦"apoc.create.node(['Label'], {key:value,...}) - create node with dynamic labels"
"procedure"¦"apoc.create.addLabels"¦"apoc.create.addLabels( [node,id,ids,nodes], ['Label',...]) - adds the given labels to the node or nodes"
"procedure"¦"apoc.create.setProperty"¦"apoc.create.setProperty( [node,id,ids,nodes], key, value) - sets the given property on the node(s)"
"procedure"¦"apoc.create.setRelProperty"¦"apoc.create.setRelProperty( [rel,id,ids,rels], key, value) - sets the given property on the relationship(s)"
"procedure"¦"apoc.create.setProperties"¦"apoc.create.setProperties( [node,id,ids,nodes], [keys], [values]) - sets the given property on the nodes(s)"
"procedure"¦"apoc.create.setRelProperties"¦"apoc.create.setRelProperties( [rel,id,ids,rels], [keys], [values]) - sets the given property on the relationship(s)"
"procedure"¦"apoc.create.setLabels"¦"apoc.create.setLabels( [node,id,ids,nodes], ['Label',...]) - sets the given labels, non matching labels are removed on the node or nodes"
"procedure"¦"apoc.create.removeLabels"¦"apoc.create.removeLabels( [node,id,ids,nodes], ['Label',...]) - removes the given labels from the node or nodes"
"procedure"¦"apoc.create.nodes"¦"apoc.create.nodes(['Label'], [{key:value,...}]) create multiple nodes with dynamic labels"
"procedure"¦"apoc.create.relationship"¦"apoc.create.relationship(person1,'KNOWS',{key:value,...}, person2) create relationship with dynamic rel-type"
"procedure"¦"apoc.create.vNode"¦"apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node"
"procedure"¦"apoc.create.vNodes"¦"apoc.create.vNodes(['Label'], [{key:value,...}]) returns virtual nodes"
"procedure"¦"apoc.create.vRelationship"¦"apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship"
"procedure"¦"apoc.create.vPattern"¦"apoc.create.vPattern({_labels:['LabelA'],key:value},'KNOWS',{key:value,...}, {_labels:['LabelB'],key:value}) returns a virtual pattern"
"procedure"¦"apoc.create.vPatternFull"¦"apoc.create.vPatternFull(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual pattern"
"procedure"¦"apoc.create.uuids"¦"apoc.create.uuids(count) yield uuid - creates 'count' UUIDs "
"procedure"¦"apoc.cypher.run"¦"apoc.cypher.run(fragment, params) yield value - executes reading fragment with the given parameters"
"procedure"¦"apoc.cypher.runFile"¦"apoc.cypher.runFile(file or url) - runs each statement in the file, all semicolon separated - currently no schema operations"
"procedure"¦"apoc.cypher.runMany"¦"apoc.cypher.runMany('cypher;\nstatements;',{params}) - runs each semicolon separated statement and returns summary - currently no schema operations"
"procedure"¦"apoc.cypher.parallel"¦""
"procedure"¦"apoc.cypher.mapParallel"¦"apoc.cypher.mapParallel(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _"
"procedure"¦"apoc.cypher.mapParallel2"¦"apoc.cypher.mapParallel2(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _"
"procedure"¦"apoc.cypher.parallel2"¦""
"procedure"¦"apoc.cypher.doIt"¦"apoc.cypher.doIt(fragment, params) yield value - executes writing fragment with the given parameters"
"procedure"¦"apoc.cypher.runTimeboxed"¦"apoc.cypher.runTimeboxed('cypherStatement',{params}, timeout) - abort statement after timeout ms if not finished"
"procedure"¦"apoc.date.expire"¦"CALL apoc.date.expire(node,time,'time-unit') - expire node in given time by setting :TTL label and `ttl` property"
"procedure"¦"apoc.date.expireIn"¦"CALL apoc.date.expire.in(node,time,'time-unit') - expire node in given time-delta by setting :TTL label and `ttl` property"
"procedure"¦"apoc.es.stats"¦"apoc.es.stats(host-url-Key) - elastic search statistics"
"procedure"¦"apoc.es.get"¦"apoc.es.get(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a GET operation on elastic search"
"procedure"¦"apoc.es.query"¦"apoc.es.query(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a SEARCH operation on elastic search"
"procedure"¦"apoc.es.getRaw"¦"apoc.es.getRaw(host-or-port,path,payload-or-null) yield value - perform a raw GET operation on elastic search"
"procedure"¦"apoc.es.postRaw"¦"apoc.es.postRaw(host-or-port,path,payload-or-null) yield value - perform a raw POST operation on elastic search"
"procedure"¦"apoc.es.post"¦"apoc.es.post(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a POST operation on elastic search"
"procedure"¦"apoc.es.put"¦"apoc.es.put(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a PUT operation on elastic search"
"procedure"¦"apoc.example.movies"¦"apoc.example.movies() | Creates the sample movies graph"
"procedure"¦"apoc.export.csv.all"¦""
"procedure"¦"apoc.export.csv.data"¦""
"procedure"¦"apoc.export.csv.graph"¦""
"procedure"¦"apoc.export.csv.query"¦""
"procedure"¦"apoc.export.cypher.all"¦"apoc.export.cypher.all(file,config) - exports whole database incl. indexes as cypher statements to the provided file"
"procedure"¦"apoc.export.cypher.data"¦"apoc.export.cypher.data(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file"
"procedure"¦"apoc.export.cypher.graph"¦"apoc.export.cypher.graph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file"
"procedure"¦"apoc.export.cypher.query"¦"apoc.export.cypher.query(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file"
"procedure"¦"apoc.export.cypherAll"¦"apoc.export.cypherAll(file,config) - exports whole database incl. indexes as cypher statements to the provided file"
"procedure"¦"apoc.export.cypherData"¦"apoc.export.cypherData(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file"
"procedure"¦"apoc.export.cypherGraph"¦"apoc.export.cypherGraph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file"
"procedure"¦"apoc.export.cypherQuery"¦"apoc.export.cypherQuery(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file"
"procedure"¦"apoc.import.graphml"¦"apoc.import.graphml(file,config) - imports graphml file"
"procedure"¦"apoc.export.graphml.all"¦"apoc.export.graphml.all(file,config) - exports whole database as graphml to the provided file"
"procedure"¦"apoc.export.graphml.data"¦"apoc.export.graphml.data(nodes,rels,file,config) - exports given nodes and relationships as graphml to the provided file"
"procedure"¦"apoc.export.graphml.graph"¦"apoc.export.graphml.graph(graph,file,config) - exports given graph object as graphml to the provided file"
"procedure"¦"apoc.export.graphml.query"¦"apoc.export.graphml.query(query,file,config) - exports nodes and relationships from the cypher statement as graphml to the provided file"
"procedure"¦"apoc.generate.ba"¦"apoc.generate.ba(noNodes, edgesPerNode, label, type) - generates a random graph according to the Barabasi-Albert model"
"procedure"¦"apoc.generate.ws"¦"apoc.generate.ws(noNodes, degree, beta, label, type) - generates a random graph according to the Watts-Strogatz model"
"procedure"¦"apoc.generate.er"¦"apoc.generate.er(noNodes, noEdges, label, type) - generates a random graph according to the Erdos-Renyi model"
"procedure"¦"apoc.generate.complete"¦"apoc.generate.complete(noNodes, label, type) - generates a random complete graph"
"procedure"¦"apoc.generate.simple"¦"apoc.generate.simple(degrees, label, type) - generates a simple random graph according to the given degree distribution"
"procedure"¦"apoc.gephi.add"¦"apoc.gephi.add(url-or-key, workspace, data, weightproperty) | streams passed in data to Gephi"
"procedure"¦"apoc.get.nodes"¦"apoc.get.nodes(node|id|[ids]) - quickly returns all nodes with these id's"
"procedure"¦"apoc.get.rels"¦"apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id's"
"procedure"¦"apoc.graph.fromData"¦"apoc.graph.fromData([nodes],[relationships],'name',{properties}) | creates a virtual graph object for later processing"
"procedure"¦"apoc.graph.from"¦"apoc.graph.from(data,'name',{properties}) | creates a virtual graph object for later processing it tries its best to extract the graph information from the data you pass in"
"procedure"¦"apoc.graph.fromPath"¦"apoc.graph.fromPaths(path,'name',{properties}) - creates a virtual graph object for later processing"
"procedure"¦"apoc.graph.fromPaths"¦"apoc.graph.fromPaths([paths],'name',{properties}) - creates a virtual graph object for later processing"
"procedure"¦"apoc.graph.fromDB"¦"apoc.graph.fromDB('name',{properties}) - creates a virtual graph object for later processing"
"procedure"¦"apoc.graph.fromCypher"¦"apoc.graph.fromCypher('statement',{params},'name',{properties}) - creates a virtual graph object for later processing"
"procedure"¦"apoc.help"¦"Provides descriptions of available procedures. To narrow the results, supply a search string. To also search in the description text, append + to the end of the search string."
"procedure"¦"apoc.index.addAllNodes"¦"apoc.index.addAllNodes('name',{label1:['prop1',...],...}, {options}) YIELD type, name, config - create a free text search index"
"procedure"¦"apoc.index.addAllNodesExtended"¦"apoc.index.addAllNodesExtended('name',{label1:['prop1',...],...}, {options}) YIELD type, name, config - create a free text search index with special options"
"procedure"¦"apoc.index.search"¦"apoc.index.search('name', 'query') YIELD node, weight - search for nodes in the free text index matching the given query"
"procedure"¦"apoc.index.nodes"¦"apoc.index.nodes('Label','prop:value*') YIELD node - lucene query on node index with the given label name"
"procedure"¦"apoc.index.forNodes"¦"apoc.index.forNodes('name',{config}) YIELD type,name,config - gets or creates node index"
"procedure"¦"apoc.index.forRelationships"¦"apoc.index.forRelationships('name',{config}) YIELD type,name,config - gets or creates relationship index"
"procedure"¦"apoc.index.remove"¦"apoc.index.remove('name') YIELD type,name,config - removes an manual index"
"procedure"¦"apoc.index.list"¦"apoc.index.list() - YIELD type,name,config - lists all manual indexes"
"procedure"¦"apoc.index.relationships"¦"apoc.index.relationships('TYPE','prop:value*') YIELD rel - lucene query on relationship index with the given type name"
"procedure"¦"apoc.index.between"¦"apoc.index.between(node1,'TYPE',node2,'prop:value*') YIELD rel - lucene query on relationship index with the given type name bound by either or both sides (each node parameter can be null)"
"procedure"¦"apoc.index.out"¦"apoc.index.out(node,'TYPE','prop:value*') YIELD node - lucene query on relationship index with the given type name for *outgoing* relationship of the given node, *returns end-nodes*"
"procedure"¦"apoc.index.in"¦"apoc.index.in(node,'TYPE','prop:value*') YIELD node lucene query on relationship index with the given type name for *incoming* relationship of the given node, *returns start-nodes*"
"procedure"¦"apoc.index.addNode"¦"apoc.index.addNode(node,['prop1',...]) add node to an index for each label it has"
"procedure"¦"apoc.index.addNodeByLabel"¦"apoc.index.addNodeByLabel(node,'Label',['prop1',...]) add node to an index for the given label"
"procedure"¦"apoc.index.addNodeByName"¦"apoc.index.addNodeByName('name',node,['prop1',...]) add node to an index for the given name"
"procedure"¦"apoc.index.addRelationship"¦"apoc.index.addRelationship(rel,['prop1',...]) add relationship to an index for its type"
"procedure"¦"apoc.index.addRelationshipByName"¦"apoc.index.addRelationshipByName('name',rel,['prop1',...]) add relationship to an index for the given name"
"procedure"¦"apoc.index.removeNodeByName"¦"apoc.index.removeNodeByName('name',node) remove node from an index for the given name"
"procedure"¦"apoc.index.removeRelationshipByName"¦"apoc.index.removeRelationshipByName('name',rel) remove relationship from an index for the given name"
"procedure"¦"apoc.index.related"¦"apoc.index.relatedNodes([nodes],label,key,'<TYPE'/'TYPE>'/'TYPE',limit) yield node - schema range scan which keeps index order and adds limit and checks opposite node of relationship against the given set of nodes"
"procedure"¦"apoc.index.orderedRange"¦"apoc.index.orderedRange(label,key,min,max,sort-relevance,limit) yield node - schema range scan which keeps index order and adds limit, values can be null, boundaries are inclusive"
"procedure"¦"apoc.index.orderedByText"¦"apoc.index.orderedByText(label,key,operator,value,sort-relevance,limit) yield node - schema string search which keeps index order and adds limit, operator is 'STARTS WITH' or 'CONTAINS'"
"procedure"¦"apoc.schema.properties.distinct"¦"apoc.schema.properties.distinct(label, key) - quickly returns all distinct values for a given key"
"procedure"¦"apoc.load.driver"¦"apoc.load.driver('org.apache.derby.jdbc.EmbeddedDriver') register JDBC driver of source database"
"procedure"¦"apoc.load.jdbc"¦"apoc.load.jdbc('key or url','table or statement') YIELD row - load from relational database, from a full table or a sql statement"
"procedure"¦"apoc.load.jdbcParams"¦"apoc.load.jdbcParams('key or url','statement',[params]) YIELD row - load from relational database, from a sql statement with parameters"
"procedure"¦"apoc.load.csv"¦"apoc.load.csv('url',{config}) YIELD lineNo, list, map - load CSV fom URL as stream of values,
 config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}"
"procedure"¦"apoc.load.jsonArray"¦"apoc.load.jsonArray('url') YIELD value - load array from JSON URL (e.g. web-api) to import JSON as stream of values"
"procedure"¦"apoc.load.json"¦"apoc.load.json('url') YIELD value -  import JSON as stream of values if the JSON was an array or a single value if it was a map"
"procedure"¦"apoc.load.jsonParams"¦"apoc.load.jsonParams('url',{header:value},payload) YIELD value - load from JSON URL (e.g. web-api) while sending headers / payload to import JSON as stream of values if the JSON was an array or a single value if it was a map"
"procedure"¦"apoc.load.xml"¦"apoc.load.xml('http://example.com/test.xml', false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields."
"procedure"¦"apoc.load.xmlSimple"¦"apoc.load.xmlSimple('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _children fields. This method does intentionally not work with XML mixed content."
"procedure"¦"apoc.lock.all"¦"apoc.lock.all([nodes],[relationships]) acquires a write lock on the given nodes and relationships"
"procedure"¦"apoc.lock.nodes"¦"apoc.lock.nodes([nodes]) acquires a write lock on the given nodes"
"procedure"¦"apoc.lock.rels"¦"apoc.lock.rels([relationships]) acquires a write lock on the given relationship"
"procedure"¦"apoc.meta.stats"¦"apoc.meta.stats  yield labelCount, relTypeCount, propertyKeyCount, nodeCount, relCount, labels, relTypes, stats | returns the information stored in the transactional database statistics"
"procedure"¦"apoc.meta.data"¦"apoc.meta.data  - examines a subset of the graph to provide a tabular meta information"
"procedure"¦"apoc.meta.graph"¦"apoc.meta.graph - examines the full graph to create the meta-graph"
"procedure"¦"apoc.meta.graphSample"¦"apoc.meta.graphSample() - examines the database statistics to build the meta graph, very fast, might report extra relationships"
"procedure"¦"apoc.meta.subGraph"¦"apoc.meta.subGraph({labels:[labels],rels:[rel-types], excludes:[labels,rel-types]}) - examines a sample sub graph to create the meta-graph"
"procedure"¦"apoc.mongodb.get"¦"apoc.mongodb.get(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a find operation on mongodb collection"
"procedure"¦"apoc.mongodb.count"¦"apoc.mongodb.count(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a find operation on mongodb collection"
"procedure"¦"apoc.mongodb.first"¦"apoc.mongodb.first(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a first operation on mongodb collection"
"procedure"¦"apoc.mongodb.find"¦"apoc.mongodb.find(host-or-port,db-or-null,collection-or-null,query-or-null,projection-or-null,sort-or-null) yield value - perform a find,project,sort operation on mongodb collection"
"procedure"¦"apoc.mongodb.insert"¦"apoc.mongodb.insert(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection"
"procedure"¦"apoc.mongodb.delete"¦"apoc.mongodb.delete(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection"
"procedure"¦"apoc.mongodb.update"¦"apoc.mongodb.update(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection"
"procedure"¦"apoc.monitor.ids"¦"apoc.monitor.ids() returns the object ids in use for this neo4j instance"
"procedure"¦"apoc.monitor.kernel"¦"apoc.monitor.kernel() returns informations about the neo4j kernel"
"procedure"¦"apoc.monitor.locks"¦"apoc.monitor.locks(minWaitTime) yield advertedDeadLocks, lockCount, contendedLockCount, minimumWaitTimeMs, contendedLocks, info"
"procedure"¦"apoc.monitor.store"¦"apoc.monitor.store() returns informations about the sizes of the different parts of the neo4j graph store"
"procedure"¦"apoc.monitor.tx"¦"apoc.monitor.tx() returns informations about the neo4j transaction manager"
"procedure"¦"apoc.nodes.link"¦"apoc.nodes.link([nodes],'REL_TYPE') - creates a linked list of nodes from first to last"
"procedure"¦"apoc.nodes.get"¦"apoc.nodes.get(node|nodes|id|[ids]) - quickly returns all nodes with these id's"
"procedure"¦"apoc.nodes.delete"¦"apoc.nodes.delete(node|nodes|id|[ids]) - quickly delete all nodes with these id's"
"procedure"¦"apoc.nodes.rels"¦"apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id's"
"procedure"¦"apoc.path.expand"¦"apoc.path.expand(startNode <id>|Node|list, 'TYPE|TYPE_OUT>|<TYPE_IN', '+YesLabel|-NoLabel', minLevel, maxLevel ) yield path expand from start node following the given relationships from min to max-level adhering to the label filters"
"procedure"¦"apoc.path.expandConfig"¦"apoc.path.expandConfig(startNode <id>|Node|list, {minLevel,maxLevel,uniqueness,relationshipFilter,labelFilter,uniqueness:'RELATIONSHIP_PATH',bfs:true, filterStartNode:false}) yield path expand from start node following the given relationships from min to max-level adhering to the label filters"
"procedure"¦"apoc.path.subgraphNodes"¦"apoc.path.subgraphNodes(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false}) yield node expand the subgraph nodes reachable from start node following relationships to max-level adhering to the label filters"
"procedure"¦"apoc.path.subgraphAll"¦"apoc.path.subgraphAll(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false}) yield nodes, relationships expand the subgraph reachable from start node following relationships to max-level adhering to the label filters, and also return all relationships within the subgraph"
"procedure"¦"apoc.path.spanningTree"¦"apoc.path.spanningTree(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false}) yield path expand a spanning tree reachable from start node following relationships to max-level adhering to the label filters"
"procedure"¦"apoc.periodic.list"¦"apoc.periodic.list - list all jobs"
"procedure"¦"apoc.periodic.commit"¦"apoc.periodic.commit(statement,params) - runs the given statement in separate transactions until it returns 0"
"procedure"¦"apoc.periodic.cancel"¦"apoc.periodic.cancel(name) - cancel job with the given name"
"procedure"¦"apoc.periodic.submit"¦"apoc.periodic.submit('name',statement) - submit a one-off background statement"
"procedure"¦"apoc.periodic.repeat"¦"apoc.periodic.repeat('name',statement,repeat-rate-in-seconds) submit a repeatedly-called background statement"
"procedure"¦"apoc.periodic.rock_n_roll_while"¦"apoc.periodic.rock_n_roll_while('some cypher for knowing when to stop', 'some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows"
"procedure"¦"apoc.periodic.iterate"¦"apoc.periodic.iterate('statement returning items', 'statement per item', {batchSize:1000,iterateList:false,parallel:true}) YIELD batches, total - run the second statement for each item returned by the first statement. Returns number of batches and total processed rows"
"procedure"¦"apoc.periodic.rock_n_roll"¦"apoc.periodic.rock_n_roll('some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows"
"procedure"¦"apoc.refactor.extractNode"¦"apoc.refactor.extractNode([rel1,rel2,...], [labels],'OUT','IN') extract node from relationships"
"procedure"¦"apoc.refactor.collapseNode"¦"apoc.refactor.collapseNode([node1,node2],'TYPE') collapse node to relationship, node with one rel becomes self-relationship"
"procedure"¦"apoc.refactor.cloneNodes"¦"apoc.refactor.cloneNodes([node1,node2,...]) clone nodes with their labels and properties"
"procedure"¦"apoc.refactor.cloneNodesWithRelationships"¦"apoc.refactor.cloneNodesWithRelationships([node1,node2,...]) clone nodes with their labels, properties and relationships"
"procedure"¦"apoc.refactor.mergeNodes"¦"apoc.refactor.mergeNodes([node1,node2]) merge nodes onto first in list"
"procedure"¦"apoc.refactor.setType"¦"apoc.refactor.setType(rel, 'NEW-TYPE') change relationship-type"
"procedure"¦"apoc.refactor.to"¦"apoc.refactor.to(rel, endNode) redirect relationship to use new end-node"
"procedure"¦"apoc.refactor.invert"¦"apoc.refactor.invert(rel) inverts relationship direction"
"procedure"¦"apoc.refactor.from"¦"apoc.refactor.from(rel, startNode) redirect relationship to use new start-node"
"procedure"¦"apoc.refactor.normalizeAsBoolean"¦"apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean"
"procedure"¦"apoc.refactor.categorize"¦"apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it"
"procedure"¦"apoc.search.nodeAllReduced"¦"Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched property. apoc.search.nodeShortAll( map of label and properties which will be searched upon, operator: EXACT / CONTAINS / STARTS WITH | ENDS WITH /Â = / <> / < / > ..., value ). All 'hits' are returned."
"procedure"¦"apoc.search.nodeReduced"¦"Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.nodeReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record."
"procedure"¦"apoc.search.multiSearchReduced"¦"Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.multiSearchReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record."
"procedure"¦"apoc.search.nodeAll"¦"Do a parallel search over multiple indexes returning nodes. usage apoc.search.nodeAll( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the Nodes found in the different searches."
"procedure"¦"apoc.search.node"¦"Do a parallel search over multiple indexes returning nodes. usage apoc.search.node( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the DISTINCT Nodes found in the different searches."
"procedure"¦"apoc.spatial.sortByDistance"¦"apoc.spatial.sortPathsByDistance(List<Path>) sort the given paths based on the geo informations (lat/long) in ascending order"
"procedure"¦"apoc.spatial.geocodeOnce"¦"apoc.spatial.geocodeOnce('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from openstreetmap geocoding service"
"procedure"¦"apoc.spatial.geocode"¦"apoc.spatial.geocode('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from openstreetmap geocoding service"
"procedure"¦"apoc.text.phonetic"¦"apoc.text.phonetic(value) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings"
"procedure"¦"apoc.text.phoneticDelta"¦"apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta - Compute the US_ENGLISH soundex character difference between two given strings"
"procedure"¦"apoc.trigger.add"¦""
"procedure"¦"apoc.trigger.remove"¦""
"procedure"¦"apoc.trigger.list"¦""
"procedure"¦"apoc.util.sleep"¦"apoc.util.sleep(<duration>) | sleeps for <duration> millis, transaction termination is honored"
"procedure"¦"apoc.util.validate"¦"apoc.util.validate(predicate, message, params) | if the predicate yields to true raise an exception"
"procedure"¦"apoc.warmup.run"¦"apoc.warmup.run() - quickly loads all nodes and rels into memory by skipping one page at a time"
"function"¦"apoc.algo.cosineSimilarity"¦"apoc.algo.cosineSimilarity([vector1], [vector2]) given two collection vectors, calculate cosine similarity"
"function"¦"apoc.algo.euclideanDistance"¦"apoc.algo.euclideanDistance([vector1], [vector2]) given two collection vectors, calculate the euclidean distance (square root of the sum of the squared differences)"
"function"¦"apoc.algo.euclideanSimilarity"¦"apoc.algo.euclideanSimilarity([vector1], [vector2]) given two collection vectors, calculate similarity based on euclidean distance"
"function"¦"apoc.bitwise.op"¦"apoc.bitwise.op(60,'|',13) bitwise operations a & b, a | b, a ^ b, ~a, a >> b, a >>> b, a << b. returns the result of the bitwise operation"
"function"¦"apoc.coll.zip"¦"apoc.coll.zip([list1],[list2])"
"function"¦"apoc.coll.pairs"¦"apoc.coll.pairs([1,2,3]) returns [1,2],[2,3],[3,null] "
"function"¦"apoc.coll.pairsMin"¦"apoc.coll.pairsMin([1,2,3]) returns [1,2],[2,3]"
"function"¦"apoc.coll.sum"¦"apoc.coll.sum([0.5,1,2.3])"
"function"¦"apoc.coll.avg"¦"apoc.coll.avg([0.5,1,2.3])"
"function"¦"apoc.coll.min"¦"apoc.coll.min([0.5,1,2.3])"
"function"¦"apoc.coll.max"¦"apoc.coll.max([0.5,1,2.3])"
"function"¦"apoc.coll.contains"¦"apoc.coll.contains(coll, value) optimized contains operation (using a HashSet) (returns single row or not)"
"function"¦"apoc.coll.indexOf"¦"apoc.coll.indexOf(coll, value) | position of value in the list"
"function"¦"apoc.coll.containsAll"¦"apoc.coll.containsAll(coll, values) optimized contains-all operation (using a HashSet) (returns single row or not)"
"function"¦"apoc.coll.containsSorted"¦"apoc.coll.containsSorted(coll, value) optimized contains on a sorted list operation (Collections.binarySearch) (returns single row or not)"
"function"¦"apoc.coll.containsAllSorted"¦"apoc.coll.containsAllSorted(coll, value) optimized contains-all on a sorted list operation (Collections.binarySearch) (returns single row or not)"
"function"¦"apoc.coll.toSet"¦"apoc.coll.toSet([list]) returns a unique list backed by a set"
"function"¦"apoc.coll.sumLongs"¦"apoc.coll.sumLongs([1,3,3])"
"function"¦"apoc.coll.sort"¦"apoc.coll.sort(coll) sort on Collections"
"function"¦"apoc.coll.sortNodes"¦"apoc.coll.sortNodes([nodes], 'name') sort nodes by property"
"function"¦"apoc.coll.sortMaps"¦"apoc.coll.sortMaps([maps], 'name') - sort maps by property"
"function"¦"apoc.coll.union"¦"apoc.coll.union(first, second) - creates the distinct union of the 2 lists"
"function"¦"apoc.coll.subtract"¦"apoc.coll.subtract(first, second) - returns unique set of first list with all elements of second list removed"
"function"¦"apoc.coll.removeAll"¦"apoc.coll.removeAll(first, second) - returns first list with all elements of second list removed"
"function"¦"apoc.coll.intersection"¦"apoc.coll.intersection(first, second) - returns the unique intersection of the two lists"
"function"¦"apoc.coll.disjunction"¦"apoc.coll.disjunction(first, second) - returns the disjunct set of the two lists"
"function"¦"apoc.coll.unionAll"¦"apoc.coll.unionAll(first, second) - creates the full union with duplicates of the two lists"
"function"¦"apoc.coll.shuffle"¦"apoc.coll.shuffle(coll) - returns the shuffled list"
"function"¦"apoc.coll.randomItem"¦"apoc.coll.randomItem(coll)- returns a random item from the list, or null on an empty or null list"
"function"¦"apoc.coll.randomItems"¦"apoc.coll.randomItems(coll, itemCount, allowRepick: false) - returns a list of itemCount random items from the original list, optionally allowing picked elements to be picked again"
"function"¦"apoc.coll.containsDuplicates"¦"apoc.coll.containsDuplicates(coll) - returns true if a collection contains duplicate elements"
"function"¦"apoc.coll.duplicates"¦"apoc.coll.duplicates(coll) - returns a list of duplicate items in the collection"
"function"¦"apoc.coll.duplicatesWithCount"¦"apoc.coll.duplicatesWithCount(coll) - returns a list of duplicate items in the collection and their count, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}]`)"
"function"¦"apoc.coll.occurrences"¦"apoc.coll.occurrences(coll, item) - returns the count of the given item in the collection"
"function"¦"apoc.coll.reverse"¦"apoc.coll.reverse(coll) - returns reversed list"
"function"¦"apoc.convert.toMap"¦"apoc.convert.toMap(value) | tries it's best to convert the value to a map"
"function"¦"apoc.convert.toString"¦"apoc.convert.toString(value) | tries it's best to convert the value to a string"
"function"¦"apoc.convert.toList"¦"apoc.convert.toList(value) | tries it's best to convert the value to a list"
"function"¦"apoc.convert.toBoolean"¦"apoc.convert.toBoolean(value) | tries it's best to convert the value to a boolean"
"function"¦"apoc.convert.toNode"¦"apoc.convert.toNode(value) | tries it's best to convert the value to a node"
"function"¦"apoc.convert.toRelationship"¦"apoc.convert.toRelationship(value) | tries it's best to convert the value to a relationship"
"function"¦"apoc.convert.toSet"¦"apoc.convert.toSet(value) | tries it's best to convert the value to a set"
"function"¦"apoc.json.path"¦"apoc.json.path('{json}','json-path')"
"function"¦"apoc.convert.toJson"¦"apoc.convert.toJson([1,2,3]) or toJson({a:42,b:""foo"",c:[1,2,3]})"
"function"¦"apoc.convert.getJsonProperty"¦"apoc.convert.getJsonProperty(node,key[,'json-path']) - converts serialized JSON in property back to original object"
"function"¦"apoc.convert.getJsonPropertyMap"¦"apoc.convert.getJsonPropertyMap(node,key[,'json-path']) - converts serialized JSON in property back to map"
"function"¦"apoc.convert.fromJsonMap"¦"apoc.convert.fromJsonMap('{""a"":42,""b"":""foo"",""c"":[1,2,3]}'[,'json-path'])"
"function"¦"apoc.convert.fromJsonList"¦"apoc.convert.fromJsonList('[1,2,3]'[,'json-path'])"
"function"¦"apoc.create.vNode"¦"apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node"
"function"¦"apoc.create.vRelationship"¦"apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship"
"function"¦"apoc.create.uuid"¦"apoc.create.uuid() - creates an UUID"
"function"¦"apoc.data.domain"¦"apoc.data.domain('url_or_email_address') YIELD domain - extract the domain name from a url or an email address. If nothing was found, yield null."
"function"¦"apoc.date.toYears"¦"toYears(timestap) or toYears(date[,format]) converts timestamp into floating point years"
"function"¦"apoc.date.fields"¦"apoc.date.fields('2012-12-23',('yyyy-MM-dd')) - return columns and a map representation of date parsed with the given format with entries for years,months,weekdays,days,hours,minutes,seconds,zoneid"
"function"¦"apoc.date.format"¦"apoc.date.format(12345,('ms|s|m|h|d'),('yyyy-MM-dd HH:mm:ss zzz'),('TZ')) get string representation of time value optionally using the specified unit (default ms) using specified format (default ISO) and specified time zone (default current TZ)"
"function"¦"apoc.date.parse"¦"apoc.date.parse('2012-12-23','ms|s|m|h|d','yyyy-MM-dd') parse date string using the specified format into the specified time unit"
"function"¦"apoc.date.systemTimezone"¦"apoc.date.systemTimezone() returns the system timezone display name"
"function"¦"apoc.date.convert"¦"apoc.date.convert(12345, 'ms', 'd') convert a timestamp in one time unit into one of a different time unit"
"function"¦"apoc.date.add"¦"apoc.date.add(12345, 'ms', -365, 'd') given a timestamp in one time unit, adds a value of the specified time unit"
"function"¦"apoc.map.groupBy"¦"apoc.map.groupBy([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with single values"
"function"¦"apoc.map.groupByMulti"¦"apoc.map.groupByMulti([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with list values"
"function"¦"apoc.map.fromNodes"¦"apoc.map.fromNodes(label, property)"
"function"¦"apoc.map.fromPairs"¦"apoc.map.fromPairs([[key,value],[key2,value2],...])"
"function"¦"apoc.map.fromLists"¦"apoc.map.fromLists([keys],[values])"
"function"¦"apoc.map.fromValues"¦"apoc.map.fromValues([key1,value1,key2,value2,...])"
"function"¦"apoc.map.merge"¦"apoc.map.merge(first,second) - merges two maps"
"function"¦"apoc.map.mergeList"¦"apoc.map.mergeList([{maps}]) yield value - merges all maps in the list into one"
"function"¦"apoc.map.setKey"¦"apoc.map.setKey(map,key,value)"
"function"¦"apoc.map.setEntry"¦"apoc.map.setEntry(map,key,value)"
"function"¦"apoc.map.setPairs"¦"apoc.map.setPairs(map,[[key1,value1],[key2,value2])"
"function"¦"apoc.map.setLists"¦"apoc.map.setLists(map,[keys],[values])"
"function"¦"apoc.map.setValues"¦"apoc.map.setValues(map,[key1,value1,key2,value2])"
"function"¦"apoc.map.removeKey"¦"apoc.map.removeKey(map,key)"
"function"¦"apoc.map.removeKeys"¦"apoc.map.removeKeys(map,keys)"
"function"¦"apoc.map.clean"¦"apoc.map.clean(map,[skip,keys],[skip,values]) yield map removes the keys and values contained in those lists, good for data cleaning from CSV/JSON"
"function"¦"apoc.map.flatten"¦"apoc.map.flatten(map) yield map - flattens nested items in map using dot notation"
"function"¦"apoc.math.round"¦"apoc.math.round(value,[prec],mode=[CEILING,FLOOR,UP,DOWN,HALF_EVEN,HALF_DOWN,HALF_UP,DOWN,UNNECESSARY])"
"function"¦"apoc.math.maxLong"¦"apoc.math.maxLong() | return the maximum value a long can have"
"function"¦"apoc.math.minLong"¦"apoc.math.minLong() | return the minimum value a long can have"
"function"¦"apoc.math.maxDouble"¦"apoc.math.maxDouble() | return the largest positive finite value of type double"
"function"¦"apoc.math.minDouble"¦"apoc.math.minDouble() | return the smallest positive nonzero value of type double"
"function"¦"apoc.math.maxInt"¦"apoc.math.maxInt() | return the maximum value an int can have"
"function"¦"apoc.math.minInt"¦"apoc.math.minInt() | return the minimum value an int can have"
"function"¦"apoc.math.maxByte"¦"apoc.math.maxByte() | return the maximum value an byte can have"
"function"¦"apoc.math.minByte"¦"apoc.math.minByte() | return the minimum value an byte can have"
"function"¦"apoc.meta.type"¦"apoc.meta.type(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)"
"function"¦"apoc.meta.typeName"¦"apoc.meta.typeName(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)"
"function"¦"apoc.meta.types"¦"apoc.meta.types(node-relationship-map)  - returns a map of keys to types"
"function"¦"apoc.meta.isType"¦"apoc.meta.isType(value,type) - returns a row if type name matches none if not (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)"
"function"¦"apoc.node.relationship.exists"¦"apoc.node.relationship.exists(node, rel-direction-pattern) - yields true effectively when the node has the relationships of the pattern"
"function"¦"apoc.nodes.isDense"¦"apoc.nodes.isDense(node) - returns true if it is a dense node"
"function"¦"apoc.number.format"¦"apoc.number.format(number)  | format a long or double using the default system pattern and language to produce a string"
"function"¦"apoc.number.parseInt"¦"apoc.number.parseInt(text)  | parse a text using the default system pattern and language to produce a long"
"function"¦"apoc.number.parseFloat"¦"apoc.number.parseFloat(text)  | parse a text using the default system pattern and language to produce a double"
"function"¦"apoc.plotgen.gender.gender"¦"apoc.plotgen.gender.gender()"
"function"¦"apoc.plotgen.names.humanSurnameP1"¦"apoc.plotgen.names.humanSurmaneP1()"
"function"¦"apoc.plotgen.names.humanSurnameP2"¦"apoc.plotgen.names.humanSurmaneP2()"
"function"¦"apoc.plotgen.names.humanMale"¦"apoc.plotgen.names.humanMale()"
"function"¦"apoc.plotgen.names.humanFemale"¦"apoc.plotgen.names.humanFemale()"
"function"¦"apoc.scoring.existence"¦"apoc.scoring.existence(5, true) returns the provided score if true, 0 if false"
"function"¦"apoc.scoring.pareto"¦"apoc.scoring.pareto(10, 20, 100, 11) applies a Pareto scoring function over the inputs"
"function"¦"apoc.text.replace"¦"apoc.text.replace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement."
"function"¦"apoc.text.regreplace"¦"apoc.text.regreplace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement."
"function"¦"apoc.text.regexGroups"¦"apoc.text.regexGroups(text, regex) - return all matching groups of the regex on the given text."
"function"¦"apoc.text.join"¦"apoc.text.join(['text1','text2',...], delimiter) - join the given strings with the given delimiter."
"function"¦"apoc.text.clean"¦"apoc.text.clean(text) - strip the given string of everything except alpha numeric characters and convert it to lower case."
"function"¦"apoc.text.compareCleaned"¦"apoc.text.compareCleaned(text1, text2) - compare the given strings stripped of everything except alpha numeric characters converted to lower case."
"function"¦"apoc.text.urlencode"¦"apoc.text.urlencode(text) - return the urlencoded text"
"function"¦"apoc.text.urldecode"¦"apoc.text.urldecode(text) - return the urldecoded text"
"function"¦"apoc.text.lpad"¦"apoc.text.lpad(text,count,delim) YIELD value - left pad the string to the given width"
"function"¦"apoc.text.rpad"¦"apoc.text.rpad(text,count,delim) YIELD value - right pad the string to the given width"
"function"¦"apoc.text.format"¦"apoc.text.format(text,[params]) - sprintf format the string with the params given"
"function"¦"apoc.trigger.nodesByLabel"¦""
"function"¦"apoc.trigger.propertiesByKey"¦""
"function"¦"apoc.util.sha1"¦"apoc.util.sha1([values]) | computes the sha1 of the concatenation of all string values of the list"
"function"¦"apoc.util.md5"¦"apoc.util.md5([values]) | computes the md5 of the concatenation of all string values of the list"
