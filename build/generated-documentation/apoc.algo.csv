"type"¦"qualified name"¦"description"
"procedure"¦"apoc.algo.betweenness"¦"CALL apoc.algo.betweenness(['TYPE',...],nodes,BOTH) YIELD node, score - calculate betweenness centrality for given nodes"
"procedure"¦"apoc.algo.betweennessCypher"¦"CALL apoc.algo.betweennessCypher(node_cypher,rel_cypher,write) - calculates betweeness  centrality based on cypher input"
"procedure"¦"apoc.algo.closeness"¦"CALL apoc.algo.closeness(['TYPE',...],nodes, INCOMING) YIELD node, score - calculate closeness centrality for given nodes"
"procedure"¦"apoc.algo.cliques"¦"apoc.algo.cliques(minSize) YIELD cliques - search the graph and return all maximal cliques at least at large as the minimum size argument."
"procedure"¦"apoc.algo.cliquesWithNode"¦"apoc.algo.cliquesWithNode(startNode, minSize) YIELD cliques - search the graph and return all maximal cliques that are at least as large than the minimum size argument and contain this node "
"procedure"¦"apoc.algo.cover"¦"apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes"
"procedure"¦"apoc.algo.community"¦"CALL apoc.algo.community(times,labels,partitionKey,type,direction,weightKey,batchSize) - simple label propagation kernel"
"procedure"¦"apoc.algo.pageRank"¦"CALL apoc.algo.pageRank(nodes) YIELD node, score - calculates page rank for given nodes"
"procedure"¦"apoc.algo.pageRankWithConfig"¦"CALL apoc.algo.pageRankWithConfig(nodes,{iterations:_,types:_}) YIELD node, score, info - calculates page rank for given nodes"
"procedure"¦"apoc.algo.pageRankStats"¦"CALL apoc.algo.pageRankStats({iterations:_,types:_,write:true,...}) YIELD nodeCount - calculates page rank on graph  for given nodes and potentially writes back"
"procedure"¦"apoc.algo.pageRankWithCypher"¦"CALL apoc.algo.pageRankWithCypher({iterations,node_cypher,rel_cypher,write,property,numCpu}) - calculates page rank based on cypher input"
"procedure"¦"apoc.algo.aStar"¦"apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance','lat','lon') YIELD path, weight - run A* with relationship property name as cost function"
"procedure"¦"apoc.algo.aStarConfig"¦"apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', {weight:'dist',default:10,x:'lon',y:'lat'}) YIELD path, weight - run A* with relationship property name as cost function"
"procedure"¦"apoc.algo.dijkstra"¦"apoc.algo.dijkstra(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance') YIELD path, weight - run dijkstra with relationship property name as cost function"
"procedure"¦"apoc.algo.allSimplePaths"¦"apoc.algo.allSimplePaths(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes"
"procedure"¦"apoc.algo.dijkstraWithDefaultWeight"¦"apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist"
"procedure"¦"apoc.algo.wcc"¦"CALL apoc.algo.wcc() YIELD number of weakly connected components"
"function"¦"apoc.algo.cosineSimilarity"¦"apoc.algo.cosineSimilarity([vector1], [vector2]) given two collection vectors, calculate cosine similarity"
"function"¦"apoc.algo.euclideanDistance"¦"apoc.algo.euclideanDistance([vector1], [vector2]) given two collection vectors, calculate the euclidean distance (square root of the sum of the squared differences)"
"function"¦"apoc.algo.euclideanSimilarity"¦"apoc.algo.euclideanSimilarity([vector1], [vector2]) given two collection vectors, calculate similarity based on euclidean distance"
